function varargout = theta0(varargin)
Q = lib.ecma.struct(...
	'dX',		8,...
	'nlinfit',	{},...
	varargin{:} ...
);

% set iteration print function
sPrec	= '%1.12e';
sStrong = ['<strong>' sPrec '</strong>'];
sFormat = strjoin({'%1.3e',sPrec,sStrong,sPrec,'\n'},'\t');
fLog	= @(SOL) fprintf(sFormat,Q.response.chi2(SOL),SOL.data.beta0,SOL.data.theta0,SOL.data.W0);

% relative distance function (solution => value)
fResponse = @(SOL) 1 - Q.response.fmap(SOL)/Q.response.prediction;

% set update function ([vector,struct] => struct)
fUpdate = @(x,vm) lib.struct.setfield(vm,...
	'theta0',		x ...
);

% set model function (solution => struct)
fModel = @(SOL) lib.struct.setfield(Q.model,...
	'beta0',		SOL.data.beta0,...
	'theta0',		SOL.data.theta0,...
	'W0',			SOL.data.W0 ...
);

% set search interval
Xint(1) = Q.model.theta0 - Q.dX;
Xint(2) = Q.model.theta0 + Q.dX;

% search for solution
[varargout{1:nargout}] = lib.model.cRAR.find.bisect(...
	'model',		Q.model,...
	'Xint',			Xint,...
	'fResponse',	fResponse,...
	'fModel',		fModel,...
	'fUpdate',		fUpdate,...
	'fLog',			fLog,...
	'nlinfit',		Q.nlinfit ....
);