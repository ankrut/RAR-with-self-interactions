% load packages
CONST	= lib.ecma.require(@lib.physics.constants);
ANCH	= lib.ecma.require(@lib.model.cRAR.anchor);
AXES	= lib.ecma.require(@lib.model.cRAR.axes.astro);

% set model seed
modelSeed	= struct(...
	'm',		48*CONST.keVcc,...
	'beta0',	1E-5,...
	'theta0',	38,...
	'W0',		70,...
	'RelTol',	1E-9 ...
);

% define responses
% NOTE: the core mass is defined at the first maximum in the rotation curve
fMcore = @(obj) AXES.mass.map('data', obj, 'anchor', ANCH.velocity_core);

constraintsList = lib.profile.responseList([
	lib.profile.response('map', fMcore, 'prediction', 4.2E6);
]);

% find solution
% NOTE: there three key words available:
%   print:	don't vary, just print the value
%   linear:	vary with linear scale and print value in bold
%   log:	vary with logarithmic scale and print value in bold
[p,model] = lib.model.cRAR.find.nlinfit(...
	'model',	modelSeed,...
	'list',		constraintsList,...
	'parameter', struct(...
		'm',		'print',...
		'beta0',	'log',... % <-- in log scale it is faster and more stable
		'theta0',	'print',...
		'W0',		'print' ...
	)...
);